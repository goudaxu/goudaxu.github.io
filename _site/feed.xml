<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2021-12-26T13:34:22+08:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Gouda’s Blog</title><subtitle></subtitle><entry><title type="html">Welcome to Jekyll!</title><link href="http://0.0.0.0:4000/jekyll/update/2021/12/04/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2021-12-04T10:39:56+08:00</published><updated>2021-12-04T10:39:56+08:00</updated><id>http://0.0.0.0:4000/jekyll/update/2021/12/04/welcome-to-jekyll</id><content type="html" xml:base="http://0.0.0.0:4000/jekyll/update/2021/12/04/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">Ubuntu添加程序到桌面</title><link href="http://0.0.0.0:4000/linux/2021/12/04/Ubuntu%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F%E5%88%B0%E6%A1%8C%E9%9D%A2.html" rel="alternate" type="text/html" title="Ubuntu添加程序到桌面" /><published>2021-12-04T10:39:56+08:00</published><updated>2021-12-04T10:39:56+08:00</updated><id>http://0.0.0.0:4000/linux/2021/12/04/Ubuntu%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F%E5%88%B0%E6%A1%8C%E9%9D%A2</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2021/12/04/Ubuntu%E6%B7%BB%E5%8A%A0%E7%A8%8B%E5%BA%8F%E5%88%B0%E6%A1%8C%E9%9D%A2.html">&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;alacarte
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;原理为在该文件夹下创建文件：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.local/share/applications&lt;/code&gt;&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">sudo apt-get install alacarte 原理为在该文件夹下创建文件：~/.local/share/applications</summary></entry><entry><title type="html">linux下验证启动模式是BIOS还是UEFI</title><link href="http://0.0.0.0:4000/linux/2021/12/04/Linux%E4%B8%8B%E9%AA%8C%E8%AF%81%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8FBIOSorUEFI.html" rel="alternate" type="text/html" title="linux下验证启动模式是BIOS还是UEFI" /><published>2021-12-04T00:00:00+08:00</published><updated>2021-12-04T00:00:00+08:00</updated><id>http://0.0.0.0:4000/linux/2021/12/04/Linux%E4%B8%8B%E9%AA%8C%E8%AF%81%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8FBIOSorUEFI</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2021/12/04/Linux%E4%B8%8B%E9%AA%8C%E8%AF%81%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8FBIOSorUEFI.html">&lt;p&gt;验证启动模式
如果以在 UEFI 主板上启用 UEFI 模式，Archiso 将会使用 systemd-boot 来 启动 Arch Linux。可以列出 efivars 目录以验证启动模式：&lt;/p&gt;

&lt;h1 id=&quot;ls-sysfirmwareefiefivars&quot;&gt;ls /sys/firmware/efi/efivars&lt;/h1&gt;
&lt;p&gt;如果目录不存在，系统可能以 BIOS 或 CSM 模式启动，详见您的主板手册。&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">验证启动模式 如果以在 UEFI 主板上启用 UEFI 模式，Archiso 将会使用 systemd-boot 来 启动 Arch Linux。可以列出 efivars 目录以验证启动模式： ls /sys/firmware/efi/efivars 如果目录不存在，系统可能以 BIOS 或 CSM 模式启动，详见您的主板手册。</summary></entry><entry><title type="html">WSL中字体文件问题解决</title><link href="http://0.0.0.0:4000/linux/2021/12/04/WSL%E5%AD%97%E4%BD%93%E6%96%87%E4%BB%B6.html" rel="alternate" type="text/html" title="WSL中字体文件问题解决" /><published>2021-12-04T00:00:00+08:00</published><updated>2021-12-04T00:00:00+08:00</updated><id>http://0.0.0.0:4000/linux/2021/12/04/WSL%E5%AD%97%E4%BD%93%E6%96%87%E4%BB%B6</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2021/12/04/WSL%E5%AD%97%E4%BD%93%E6%96%87%E4%BB%B6.html">&lt;p&gt;wsl是没有中文字体的，所以在安装使用Firefox等软件时，无法正常显示中文字体，所以我们可以通过使用Windows自带字体的方式，来实现快速安装中文字体（以Ubuntu为例）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo ln -s /mnt/c/Windows/Fonts /usr/share/fonts/font&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们只需要将Windows下的字体目录链接到WSL目录下即可然后再刷新一下。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fc-cache -fv&lt;/code&gt;
这样就可以正常显示中文字体了&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">wsl是没有中文字体的，所以在安装使用Firefox等软件时，无法正常显示中文字体，所以我们可以通过使用Windows自带字体的方式，来实现快速安装中文字体（以Ubuntu为例）。 sudo ln -s /mnt/c/Windows/Fonts /usr/share/fonts/font 我们只需要将Windows下的字体目录链接到WSL目录下即可然后再刷新一下。 fc-cache -fv 这样就可以正常显示中文字体了</summary></entry><entry><title type="html">ArchLinux网络配置</title><link href="http://0.0.0.0:4000/linux/2021/12/04/archLinux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.html" rel="alternate" type="text/html" title="ArchLinux网络配置" /><published>2021-12-04T00:00:00+08:00</published><updated>2021-12-04T00:00:00+08:00</updated><id>http://0.0.0.0:4000/linux/2021/12/04/archLinux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2021/12/04/archLinux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.html">&lt;h3 id=&quot;archlinux-网络配置方法&quot;&gt;Archlinux 网络配置方法&lt;/h3&gt;

&lt;p&gt;在 Archlinux 下最简单的网络配置方式是使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemd-networkd&lt;/code&gt; 服务，默认配置文件位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/systemd/network&lt;/code&gt; 下&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemctl&lt;/code&gt; 开启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemd-networkd&lt;/code&gt; 服务&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;systemd-networkd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;配置-dhcp-动态-ip-地址&quot;&gt;配置 DHCP 动态 IP 地址&lt;/h4&gt;

&lt;p&gt;编辑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/systemd/network/enp0s3.network&lt;/code&gt; 网卡配置文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Match]
Name=enp0s3

[Network]
DHCP=ipv4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;配置-static-静态-ip-地址&quot;&gt;配置 STATIC 静态 IP 地址&lt;/h4&gt;

&lt;p&gt;编辑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/systemd/network/enp0s3.network&lt;/code&gt; 网卡配置文件&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Match]
Name=enp0s3

[Network]
Address=192.168.1.100/24
Gateway=192.168.1.1
DNS=8.8.8.8
DNS=8.8.4.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果 enp0s3.network 中添加了 DNS 选项则需要同时启用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemd-resolved.service&lt;/code&gt; 服务配合使用&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ systemctl enable systemd-resolved.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;重启网络服务使配置生效&quot;&gt;重启网络服务，使配置生效&lt;/h4&gt;

&lt;p&gt;修改网卡配置文件之后，需要重启 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemd-networkd&lt;/code&gt; 服务使配置生效&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ systemctl restart systemd-networkd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="linux" /><summary type="html">Archlinux 网络配置方法 在 Archlinux 下最简单的网络配置方式是使用 systemd-networkd 服务，默认配置文件位于 /etc/systemd/network 下 使用 systemctl 开启 systemd-networkd 服务 $ systemctl enable systemd-networkd 配置 DHCP 动态 IP 地址 编辑 /etc/systemd/network/enp0s3.network 网卡配置文件 [Match] Name=enp0s3 [Network] DHCP=ipv4 配置 STATIC 静态 IP 地址 编辑 /etc/systemd/network/enp0s3.network 网卡配置文件 [Match] Name=enp0s3 [Network] Address=192.168.1.100/24 Gateway=192.168.1.1 DNS=8.8.8.8 DNS=8.8.4.4 如果 enp0s3.network 中添加了 DNS 选项则需要同时启用 systemd-resolved.service 服务配合使用 $ systemctl enable systemd-resolved.service 重启网络服务，使配置生效 修改网卡配置文件之后，需要重启 systemd-networkd 服务使配置生效 $ systemctl restart systemd-networkd</summary></entry><entry><title type="html">ISCSI_CHAP认证</title><link href="http://0.0.0.0:4000/linux/2021/12/04/iSCSI_CHAP%E8%AE%A4%E8%AF%81.html" rel="alternate" type="text/html" title="ISCSI_CHAP认证" /><published>2021-12-04T00:00:00+08:00</published><updated>2021-12-04T00:00:00+08:00</updated><id>http://0.0.0.0:4000/linux/2021/12/04/iSCSI_CHAP%E8%AE%A4%E8%AF%81</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2021/12/04/iSCSI_CHAP%E8%AE%A4%E8%AF%81.html">&lt;h1 id=&quot;登录chap认证的iscsi-target&quot;&gt;登录CHAP认证的iSCSI target&lt;/h1&gt;

&lt;p&gt;使用iStorage Server为linux服务器创建iSCSI target ，iStorage Server 支持CHAP在内的多种认证方法，而CHAP是目前IP SAN领域最常用的安全机制。&lt;/p&gt;

&lt;p&gt;iStorage Server是kernsafe旗下的一款优秀的IP SAN服务器软件，创建target方法，可以查看官网白皮书：www.kernsafe.cn&lt;/p&gt;

&lt;h4 id=&quot;第一种全局配置的方法客户端上连接的所有target可能都会使用这个账号和密码进行认证适用于只有一个target&quot;&gt;第一种：全局配置的方法，客户端上连接的所有target可能都会使用这个账号和密码进行认证，适用于只有一个target&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@www ~]# yum -y install iscsi-initiator-utils
[root@www ~]# vi /etc/iscsi/iscsid.conf
# line 49: uncomment
node.session.auth.authmethod = CHAP
# line 53,54: uncomment and set username and password which set on iSCSI Target
node.session.auth.username = username
node.session.auth.password = password
# discover target
[root@www ~]# iscsiadm -m discovery -t sendtargets -p 10.0.0.30
Starting iscsid: Loading iSCSI transport class v2.0-870.
iscsi: registered transport (tcp)
iscsi: registered transport (iser)
cxgb3i: tag itt 0x1fff, 13 bits, age 0xf, 4 bits.
iscsi: registered transport (cxgb3i)
cnic: Broadcom NetXtreme II CNIC Driver cnic v2.1.2 (May 26, 2010)
Broadcom NetXtreme II iSCSI Driver bnx2i v2.1.1 (Mar 24, 2010)
iscsi: registered transport (bnx2i)
iscsi: registered transport (be2iscsi)
[ OK ]
10.0.0.30:3260,1 iqn.2011-07.world.server:target0
[root@www ~]# chkconfig iscsi on
[root@www ~]# chkconfig iscsid on
# login to target
[root@www ~]# iscsiadm -m node --login
Logging in to [iface: default, target: iqn.2011-07.world.server:target0, portal: 10.0.0.30,3260]
scsi2 : iSCSI Initiator over TCP/IP
scsi 2:0:0:0: RAID IET Controller 0001 PQ: 0 ANSI: 5
scsi 2:0:0:1: Direct-Access IET VIRTUAL-DISK 0001 PQ: 0 ANSI: 5
Login to [iface: default, target: iqn.2011-07.world.server:target0, portal: 10.0.0.30,3260] successful.
# confirm session
[root@www ~]# iscsiadm -m session -o show
tcp: [1] 10.0.0.30:3260,1 iqn.2011-07.world.server:target0
# confirm partitions
[root@www ~]# cat /proc/partitions
major minor #blocks name
8031457280sda
81512000sda1
8230944256sda2
253020971520dm-0
25316160384dm-1
25323809280dm-2
80104857600sdb
81104857600sdb1# added new device provided from target
# config for auto-mount when booting
[root@www ~]# vi /etc/fstab
/dev/mapper/VolGroup-lv_root / ext4 defaults 1 1
UUID=3d3f19a1-582f-4a29-a304-349750094b2c /boot ext4 defaults 1 2
/dev/mapper/VolGroup-lv_swap swap swap defaults 0 0
tmpfs /dev/shm tmpfs defaults 0 0
devpts /dev/pts devpts gid=5,mode=620 0 0
sysfs /sys sysfs defaults 0 0
proc /proc proc defaults 0 0
# add iSCSI filesystem
/dev/sdb1 /var/kvm ext4 _netdev 0 0

[root@www ~]# chkconfig netfs on
________________________________________________________________________________________________
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;方法二对特定的target进行修改假如我们同时连接了多个target必须这样&quot;&gt;方法二：对特定的target进行修改(假如我们同时连接了多个target，必须这样)&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://zlbzhu.blog.51cto.com/1413424/897422
发现target
iscsiadm -m discovery -t sendtargets -p 192.168.1.211
挂载target
iscsiadm -m node -T iqn_2013-06.com.safexjt:target00 -p 192.168.1.211 -l
配置该target,默认放在客户端/var/lib/iscsi/node下面
vi /var/lib/iscsi/nodes/iqn_2013-06.com.safexjt\:target00/192.168.1.211\,3260\,1/default
在node.session.*.* 段添加如下信息
node.session.auth.authmethod = CHAP
node.session.auth.username = jack
node.session.auth.password = jack
保存
#service iscsi restart
________________________________________________________________________________________________
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;方法三如果我们已经对target进行了discovery但是在挂载的时候提示认证失败这个时候我们也可以通过iscsiadm明明进行添加认证信息&quot;&gt;方法三：如果我们已经对target进行了discovery，但是在挂载的时候提示认证失败，这个时候我们也可以通过iscsiadm明明进行添加认证信息&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@iscsi /]#iscsiadm -m node -T iqn_2013-06.com.safexjt:target00 -p 192.168.1.211:3260 -o update --name=node.session.auth.authmethod --value=CHAP
[root@iscsi /]#iscsiadm -m node -T iqn_2013-06.com.safexjt:target00 -p 192.168.1.211:3260 -o update --name= node.session.auth.username --value=xxxxxxx
[root@iscsi /]#iscsiadm -m node -T iqn_2013-06.com.safexjt:target00 -p 192.168.1.211:3260 -o update --name= node.session.auth.password --value=xxxxxxx
需要注意的是，发现Target的命令（iscsiadm -m discovery -t sendtargets）会自动按照/etc/iscsi/iscsi.conf文件中的参数配置刷新/var/lib/iscsi/nodes下initiator登录target要使用的参数文件，所以如果通过修改/var/lib/iscsi/nodes下的文件设置好CHAP认证后又对该存储服务器执行了发现target的操作，则需要再次修改该文件。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;一单向认证&quot;&gt;一、单向认证&lt;/h3&gt;

&lt;p&gt;单向认证是仅initiator连接target时进行认证。这个配置比较简单，打开/etc/iscsi/iscsid.conf 文件，找到如下三项并取消注释：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bsh&quot;&gt;node.session.auth.authmethod = CHAP   //开启CHAP认证
node.session.auth.username = redhat    //配置账号
node.session.auth.password = redhat123  //密码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过以下命令重启服务并生效：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bsh&quot;&gt;/etc/init.d/iscsid restart
或
systemctl restart iscsid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的配置只是在开机自启动时会查找该配置中的信息，如果想要通过命令行测试用户名密码的有效性可以使用如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bsh&quot;&gt;# 发现target
iscsiadm -m discovery -t sendtargets -p 10.131.131.150  //发现
iscsiadm -m node -T iqn.2006-08.com.huawei:oceanstor:10.131.131.150 -l   //登陆
iscsiadm -m node -o delete -T iqn.2006-08.com.huawei:oceanstor:10.131.131.150 //删除session
# 使用用户名密码
iscsiadm -m node -o update -p 10.131.131.150 -n node.session.auth.authmethod -v CHAP
iscsiadm -m node -o update -p 10.131.131.150 -n node.session.auth.username -v myusername
iscsiadm -m node -o update -p 10.131.131.150 -n node.session.auth.password -v mypassword
# 也可以使用下面的格式
iscsiadm -m node -T iqn.2006-08.com.huawei:oceanstor:10.131.131.150 -o update --name node.session.auth.authmethod --value=CHAP
iscsiadm -m node -T iqn.2006-08.com.huawei:oceanstor:10.131.131.150 --op update --name node.session.auth.username --value=myusername
iscsiadm -m node -T iqn.2006-08.com.huawei:oceanstor:10.131.131.150 --op update --name node.session.auth.password --value=mypassword
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接后，可以使用如下命令查看连接状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bsh&quot;&gt;# 查看状态
iscsiadm -m node
iscsiadm -m node -o show
# 查看连接后状态
iscsiadm -m session -o show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的连接状态信息，也可以通过进入/var/lib/iscsi/ifaces/目录通过查看文件进行查看。对于已经连接过的session，可以使用如下命令删除该session：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bsh&quot;&gt;for iqn in `iscsiadm -m node|awk '{print $NF}'`;do iscsiadm -m node -T $iqn -u;done
for iqn in `iscsiadm -m node|awk '{print $NF}'`;do iscsiadm -m node -o delete -T $iqn;done
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;二双向认证&quot;&gt;二、双向认证&lt;/h3&gt;

&lt;p&gt;双向认证就是在Initiator端和target端都进行认证。Initiator 认证：在initiator尝试连接到一个target的时候，initator需要提供一个用户名和密码给target供target进行认证。下面我们称这个用户名密码为incoming账号，即：incoming账号是initiator端提供给target端，供target端认证的账号。target 认证：在initiator尝试连接到一个target的时候，target需要提供一个用户名和密码给initiator供initiator进行认证。与之对应的是outcoming账号，即：outcoming账号是target端提供给initiator端，供initiator认证的账号。双向认证的配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bsh&quot;&gt;# To set a CHAP username and password for initiator
# authentication by the target(s), uncomment the following lines:
node.session.auth.username = username
node.session.auth.password = password
# To set a CHAP username and password for target(s)
# authentication by the initiator, uncomment the following lines:
node.session.auth.username_in = username_in
node.session.auth.password_in = password_in
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;三有关多路径聚合&quot;&gt;三、有关多路径聚合&lt;/h3&gt;

&lt;p&gt;存储端一般会有多控，也就是可以由多个对应的IP可供discovery 和 login使用，比如一个两控的就会使用如下的方式进行挂载：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bsh&quot;&gt;# iscsiadm -m node -p &amp;lt;存储系统A控iSCSI主机端口的IP-A&amp;gt; -l# iscsiadm -m node -p &amp;lt;存储系统B控iSCSI主机端口的IP-B&amp;gt; -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来可以使用多路径软件进行聚合，这里以multipath为例，使用如下指令生成配置文件并重启服务生效。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bsh&quot;&gt;# mpathconf --enable# mpathconf --with_module y# mpathconf --with_multipathd y
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">登录CHAP认证的iSCSI target 使用iStorage Server为linux服务器创建iSCSI target ，iStorage Server 支持CHAP在内的多种认证方法，而CHAP是目前IP SAN领域最常用的安全机制。 iStorage Server是kernsafe旗下的一款优秀的IP SAN服务器软件，创建target方法，可以查看官网白皮书：www.kernsafe.cn 第一种：全局配置的方法，客户端上连接的所有target可能都会使用这个账号和密码进行认证，适用于只有一个target [root@www ~]# yum -y install iscsi-initiator-utils [root@www ~]# vi /etc/iscsi/iscsid.conf # line 49: uncomment node.session.auth.authmethod = CHAP # line 53,54: uncomment and set username and password which set on iSCSI Target node.session.auth.username = username node.session.auth.password = password # discover target [root@www ~]# iscsiadm -m discovery -t sendtargets -p 10.0.0.30 Starting iscsid: Loading iSCSI transport class v2.0-870. iscsi: registered transport (tcp) iscsi: registered transport (iser) cxgb3i: tag itt 0x1fff, 13 bits, age 0xf, 4 bits. iscsi: registered transport (cxgb3i) cnic: Broadcom NetXtreme II CNIC Driver cnic v2.1.2 (May 26, 2010) Broadcom NetXtreme II iSCSI Driver bnx2i v2.1.1 (Mar 24, 2010) iscsi: registered transport (bnx2i) iscsi: registered transport (be2iscsi) [ OK ] 10.0.0.30:3260,1 iqn.2011-07.world.server:target0 [root@www ~]# chkconfig iscsi on [root@www ~]# chkconfig iscsid on # login to target [root@www ~]# iscsiadm -m node --login Logging in to [iface: default, target: iqn.2011-07.world.server:target0, portal: 10.0.0.30,3260] scsi2 : iSCSI Initiator over TCP/IP scsi 2:0:0:0: RAID IET Controller 0001 PQ: 0 ANSI: 5 scsi 2:0:0:1: Direct-Access IET VIRTUAL-DISK 0001 PQ: 0 ANSI: 5 Login to [iface: default, target: iqn.2011-07.world.server:target0, portal: 10.0.0.30,3260] successful. # confirm session [root@www ~]# iscsiadm -m session -o show tcp: [1] 10.0.0.30:3260,1 iqn.2011-07.world.server:target0 # confirm partitions [root@www ~]# cat /proc/partitions major minor #blocks name 8031457280sda 81512000sda1 8230944256sda2 253020971520dm-0 25316160384dm-1 25323809280dm-2 80104857600sdb 81104857600sdb1# added new device provided from target # config for auto-mount when booting [root@www ~]# vi /etc/fstab /dev/mapper/VolGroup-lv_root / ext4 defaults 1 1 UUID=3d3f19a1-582f-4a29-a304-349750094b2c /boot ext4 defaults 1 2 /dev/mapper/VolGroup-lv_swap swap swap defaults 0 0 tmpfs /dev/shm tmpfs defaults 0 0 devpts /dev/pts devpts gid=5,mode=620 0 0 sysfs /sys sysfs defaults 0 0 proc /proc proc defaults 0 0 # add iSCSI filesystem /dev/sdb1 /var/kvm ext4 _netdev 0 0 [root@www ~]# chkconfig netfs on ________________________________________________________________________________________________ 方法二：对特定的target进行修改(假如我们同时连接了多个target，必须这样) http://zlbzhu.blog.51cto.com/1413424/897422 发现target iscsiadm -m discovery -t sendtargets -p 192.168.1.211 挂载target iscsiadm -m node -T iqn_2013-06.com.safexjt:target00 -p 192.168.1.211 -l 配置该target,默认放在客户端/var/lib/iscsi/node下面 vi /var/lib/iscsi/nodes/iqn_2013-06.com.safexjt\:target00/192.168.1.211\,3260\,1/default 在node.session.*.* 段添加如下信息 node.session.auth.authmethod = CHAP node.session.auth.username = jack node.session.auth.password = jack 保存 #service iscsi restart ________________________________________________________________________________________________ 方法三：如果我们已经对target进行了discovery，但是在挂载的时候提示认证失败，这个时候我们也可以通过iscsiadm明明进行添加认证信息 root@iscsi /]#iscsiadm -m node -T iqn_2013-06.com.safexjt:target00 -p 192.168.1.211:3260 -o update --name=node.session.auth.authmethod --value=CHAP [root@iscsi /]#iscsiadm -m node -T iqn_2013-06.com.safexjt:target00 -p 192.168.1.211:3260 -o update --name= node.session.auth.username --value=xxxxxxx [root@iscsi /]#iscsiadm -m node -T iqn_2013-06.com.safexjt:target00 -p 192.168.1.211:3260 -o update --name= node.session.auth.password --value=xxxxxxx 需要注意的是，发现Target的命令（iscsiadm -m discovery -t sendtargets）会自动按照/etc/iscsi/iscsi.conf文件中的参数配置刷新/var/lib/iscsi/nodes下initiator登录target要使用的参数文件，所以如果通过修改/var/lib/iscsi/nodes下的文件设置好CHAP认证后又对该存储服务器执行了发现target的操作，则需要再次修改该文件。 一、单向认证 单向认证是仅initiator连接target时进行认证。这个配置比较简单，打开/etc/iscsi/iscsid.conf 文件，找到如下三项并取消注释： node.session.auth.authmethod = CHAP //开启CHAP认证 node.session.auth.username = redhat //配置账号 node.session.auth.password = redhat123 //密码 通过以下命令重启服务并生效： /etc/init.d/iscsid restart 或 systemctl restart iscsid 上面的配置只是在开机自启动时会查找该配置中的信息，如果想要通过命令行测试用户名密码的有效性可以使用如下命令： # 发现target iscsiadm -m discovery -t sendtargets -p 10.131.131.150 //发现 iscsiadm -m node -T iqn.2006-08.com.huawei:oceanstor:10.131.131.150 -l //登陆 iscsiadm -m node -o delete -T iqn.2006-08.com.huawei:oceanstor:10.131.131.150 //删除session # 使用用户名密码 iscsiadm -m node -o update -p 10.131.131.150 -n node.session.auth.authmethod -v CHAP iscsiadm -m node -o update -p 10.131.131.150 -n node.session.auth.username -v myusername iscsiadm -m node -o update -p 10.131.131.150 -n node.session.auth.password -v mypassword # 也可以使用下面的格式 iscsiadm -m node -T iqn.2006-08.com.huawei:oceanstor:10.131.131.150 -o update --name node.session.auth.authmethod --value=CHAP iscsiadm -m node -T iqn.2006-08.com.huawei:oceanstor:10.131.131.150 --op update --name node.session.auth.username --value=myusername iscsiadm -m node -T iqn.2006-08.com.huawei:oceanstor:10.131.131.150 --op update --name node.session.auth.password --value=mypassword 连接后，可以使用如下命令查看连接状态： # 查看状态 iscsiadm -m node iscsiadm -m node -o show # 查看连接后状态 iscsiadm -m session -o show 上面的连接状态信息，也可以通过进入/var/lib/iscsi/ifaces/目录通过查看文件进行查看。对于已经连接过的session，可以使用如下命令删除该session： for iqn in `iscsiadm -m node|awk '{print $NF}'`;do iscsiadm -m node -T $iqn -u;done for iqn in `iscsiadm -m node|awk '{print $NF}'`;do iscsiadm -m node -o delete -T $iqn;done 二、双向认证 双向认证就是在Initiator端和target端都进行认证。Initiator 认证：在initiator尝试连接到一个target的时候，initator需要提供一个用户名和密码给target供target进行认证。下面我们称这个用户名密码为incoming账号，即：incoming账号是initiator端提供给target端，供target端认证的账号。target 认证：在initiator尝试连接到一个target的时候，target需要提供一个用户名和密码给initiator供initiator进行认证。与之对应的是outcoming账号，即：outcoming账号是target端提供给initiator端，供initiator认证的账号。双向认证的配置如下： # To set a CHAP username and password for initiator # authentication by the target(s), uncomment the following lines: node.session.auth.username = username node.session.auth.password = password # To set a CHAP username and password for target(s) # authentication by the initiator, uncomment the following lines: node.session.auth.username_in = username_in node.session.auth.password_in = password_in 三、有关多路径聚合 存储端一般会有多控，也就是可以由多个对应的IP可供discovery 和 login使用，比如一个两控的就会使用如下的方式进行挂载： # iscsiadm -m node -p &amp;lt;存储系统A控iSCSI主机端口的IP-A&amp;gt; -l# iscsiadm -m node -p &amp;lt;存储系统B控iSCSI主机端口的IP-B&amp;gt; -l 接下来可以使用多路径软件进行聚合，这里以multipath为例，使用如下指令生成配置文件并重启服务生效。 # mpathconf --enable# mpathconf --with_module y# mpathconf --with_multipathd y</summary></entry><entry><title type="html">MACOS临时禁用IPv6</title><link href="http://0.0.0.0:4000/linux/2021/12/04/mac_os%E7%A6%81%E7%94%A8%E4%B8%B4%E6%97%B6Ipv6.html" rel="alternate" type="text/html" title="MACOS临时禁用IPv6" /><published>2021-12-04T00:00:00+08:00</published><updated>2021-12-04T00:00:00+08:00</updated><id>http://0.0.0.0:4000/linux/2021/12/04/mac_os%E7%A6%81%E7%94%A8%E4%B8%B4%E6%97%B6Ipv6</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2021/12/04/mac_os%E7%A6%81%E7%94%A8%E4%B8%B4%E6%97%B6Ipv6.html">&lt;h1 id=&quot;mac-os-禁用临时ipv6&quot;&gt;MAC OS 禁用临时ipv6&lt;/h1&gt;
&lt;p&gt;Macos 可以通过对 sysctl.conf 进行修改从而达到禁用 IPv6 临时地址的问题，具体操作方法如下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;sysctl &lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; net.inet6.ip6.use_tempaddr&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0 &lt;span class=&quot;c&quot;&gt;#但是重启后会失效&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果想重启不失效手动编辑或创建 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/sysctl.conf&lt;/code&gt;文件并添加下列内容&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysctl -w net.inet6.ip6.use_tempaddr = 0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于 conf 文件的规则，最后一行需要是空行，多个换行符即多敲一个回车&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">MAC OS 禁用临时ipv6 Macos 可以通过对 sysctl.conf 进行修改从而达到禁用 IPv6 临时地址的问题，具体操作方法如下：</summary></entry><entry><title type="html">shell中!感叹号的妙用</title><link href="http://0.0.0.0:4000/linux/2021/12/04/shell%E4%B8%AD%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E5%A6%99%E7%94%A8.html" rel="alternate" type="text/html" title="shell中!感叹号的妙用" /><published>2021-12-04T00:00:00+08:00</published><updated>2021-12-04T00:00:00+08:00</updated><id>http://0.0.0.0:4000/linux/2021/12/04/shell%E4%B8%AD%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E5%A6%99%E7%94%A8</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2021/12/04/shell%E4%B8%AD%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E5%A6%99%E7%94%A8.html">&lt;p&gt;整天在shell环境下操作，不积累点快捷输入的小技巧是不行的。&lt;/p&gt;

&lt;p&gt;最常用的技巧恐怕就是Tab自动补全以及上方向键来回退上几条历史命令了，这些对于csh，bash，ksh，zsh都适用。&lt;/p&gt;

&lt;p&gt;! 符号在 Linux 中不但可以用作否定符号，还可以用来从历史命令记录中取出命令或不加修改的执行之前运行的命令。下面的所有命令都已经在 Bash Shell 中经过确切地检验。尽管我没有试过，但大多都不能在别的 Shell 中运行。这里我们介绍下 Linux 命令行中符号 ! 那惊人和奇妙的用法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行上一条命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如，在执行完上面一条命令后，可以使用下面的方式再次执行上一条命令：&lt;/p&gt;

&lt;p&gt;$ whereis bash #执行命令&lt;/p&gt;

&lt;p&gt;bash: /bin/bash /etc/bash.bashrc&lt;/p&gt;

&lt;p&gt;$ !! #再次执行上一条命令&lt;/p&gt;

&lt;p&gt;whereis bash&lt;/p&gt;

&lt;p&gt;bash: /bin/bash /etc/bash.bashrc&lt;/p&gt;

&lt;p&gt;!!代表了上一条执行的命令。可以看到，当输入两个感叹号时，它显示上条命令的同时会执行上一条命令。当然了，通常我们还会想到使用“UP”键来完成这个事情。但是如果是基于上条命令扩充，!!就来得更加方便了。&lt;/p&gt;

&lt;p&gt;比如，你想查看某个文件，但是忘了输入more：&lt;/p&gt;

&lt;p&gt;$ /opt/user/test.txt #忘记输入more&lt;/p&gt;

&lt;p&gt;$ more !! #这样是不是快多了？&lt;/p&gt;

&lt;p&gt;使用!!是不是方便多了？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用上个命令第一个或最后一个的参数执行命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用上条命令最后一个参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比如，你在使用ls列出目录内容时，没有带任何参数，但是想再次执行，带上-al参数，又不想输入长长的参数，可以使用下面的方式：&lt;/p&gt;

&lt;p&gt;$ ls /etc/udev&lt;/p&gt;

&lt;p&gt;/etc/udev&lt;/p&gt;

&lt;p&gt;$ ls -al !$&lt;/p&gt;

&lt;p&gt;ls -al /etc/udev&lt;/p&gt;

&lt;p&gt;-r–r–r– 1 root root 0 Jan 20 09:30 /etc/udev&lt;/p&gt;

&lt;p&gt;这里的!$代表了上一条命令的最后一个参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用上条命令第一个参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;而使用上条命令的第一个参数只需要使用!^，例如：&lt;/p&gt;

&lt;p&gt;$ ls -al !^&lt;/p&gt;

&lt;p&gt;去掉最后一个参数执行上一个命令&lt;/p&gt;

&lt;p&gt;如果想执行上条命令，但不想带上最后一个参数：&lt;/p&gt;

&lt;p&gt;$ ls -al dir #假设dir是一个很长的字符串&lt;/p&gt;

&lt;p&gt;$ !:-&lt;/p&gt;

&lt;p&gt;ls -al&lt;/p&gt;

&lt;p&gt;什么场景下可能会用呢？比如你上一条命令最后一个参数是一个长长的字符串，而你恰好不想不用它，并且退格键删除又慢的时候，可以使用上面的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用上条命令的所有参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面说了使用上条命令的最后一个参数，那如果不是最后一个参数，该如何使用呢？很简单，使用!*即可。例如我们在输入find命令输错了，想要纠正的时候：&lt;/p&gt;

&lt;p&gt;$ finsd -name “foo.zip” # 这里特意输错了find命令&lt;/p&gt;

&lt;p&gt;$ find !*&lt;/p&gt;

&lt;p&gt;find ./ -name “foo.zip”&lt;/p&gt;

&lt;p&gt;./bar/foo.zip&lt;/p&gt;

&lt;p&gt;./data/py/foo.zip&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用上条命令指定的参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有的读者可能会问了，如果我只想用其中某个参数呢？按照![命令名]:[参数号]的规则即可。例如：&lt;/p&gt;

&lt;p&gt;$ cp -rf dira dirb/ #将dira拷贝到dirb&lt;/p&gt;

&lt;p&gt;$ ls -l !cp:2 #查看dira的内容&lt;/p&gt;

&lt;p&gt;ls -l dira&lt;/p&gt;

&lt;p&gt;total 0&lt;/p&gt;

&lt;p&gt;-rw-rw-r– 1 hyb hyb 0 Jan 20 16:18 barfile&lt;/p&gt;

&lt;p&gt;当上条命令的参数很长，而你需要取用中间的某个参数时，效果就比较明显了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行上一条以关键字开头的命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如，执行上一条find命令：&lt;/p&gt;

&lt;p&gt;$ !find #执行上条以find开头的命令&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;逻辑非的作用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个是它最为人所熟悉的作用，例如删除除了cfg结尾以外的所有文件：&lt;/p&gt;

&lt;p&gt;rm !(*.cfg)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;惊叹号的其他惊叹功能一览：&lt;/p&gt;

&lt;p&gt;!!&lt;/p&gt;

&lt;p&gt;上一条命令&lt;/p&gt;

&lt;p&gt;!$&lt;/p&gt;

&lt;p&gt;上一条命令中的最后一个参数&lt;/p&gt;

&lt;p&gt;!:-&lt;/p&gt;

&lt;p&gt;上一命令除了最后一个参数&lt;/p&gt;

&lt;p&gt;!*&lt;/p&gt;

&lt;p&gt;上一条命令中的所有参数&lt;/p&gt;

&lt;p&gt;!str&lt;/p&gt;

&lt;p&gt;最近一条以str开头的命令&lt;/p&gt;

&lt;p&gt;!?str?&lt;/p&gt;

&lt;p&gt;最近一条包含str的命令&lt;/p&gt;

&lt;p&gt;!n&lt;/p&gt;

&lt;p&gt;顺数第n条命令&lt;/p&gt;

&lt;p&gt;!-n&lt;/p&gt;

&lt;p&gt;倒数第n条命令&lt;/p&gt;

&lt;p&gt;^old^new&lt;/p&gt;

&lt;p&gt;将上一命令中的old替换为new&lt;/p&gt;

&lt;p&gt;!!:gs/old/new&lt;/p&gt;

&lt;p&gt;将上一命令中的old替换为new&lt;/p&gt;

&lt;p&gt;!scp:gs/old/new&lt;/p&gt;

&lt;p&gt;将上一scp命令中的old替换为new&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;逻辑非的作用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个是它最为人所熟悉的作用，例如删除除了cfg结尾以外的所有文件：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rm !(*.cfg)  #删除需谨慎
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="linux" /><summary type="html">整天在shell环境下操作，不积累点快捷输入的小技巧是不行的。 最常用的技巧恐怕就是Tab自动补全以及上方向键来回退上几条历史命令了，这些对于csh，bash，ksh，zsh都适用。 ! 符号在 Linux 中不但可以用作否定符号，还可以用来从历史命令记录中取出命令或不加修改的执行之前运行的命令。下面的所有命令都已经在 Bash Shell 中经过确切地检验。尽管我没有试过，但大多都不能在别的 Shell 中运行。这里我们介绍下 Linux 命令行中符号 ! 那惊人和奇妙的用法。 执行上一条命令 例如，在执行完上面一条命令后，可以使用下面的方式再次执行上一条命令： $ whereis bash #执行命令 bash: /bin/bash /etc/bash.bashrc $ !! #再次执行上一条命令 whereis bash bash: /bin/bash /etc/bash.bashrc !!代表了上一条执行的命令。可以看到，当输入两个感叹号时，它显示上条命令的同时会执行上一条命令。当然了，通常我们还会想到使用“UP”键来完成这个事情。但是如果是基于上条命令扩充，!!就来得更加方便了。 比如，你想查看某个文件，但是忘了输入more： $ /opt/user/test.txt #忘记输入more $ more !! #这样是不是快多了？ 使用!!是不是方便多了？ 使用上个命令第一个或最后一个的参数执行命令 使用上条命令最后一个参数 比如，你在使用ls列出目录内容时，没有带任何参数，但是想再次执行，带上-al参数，又不想输入长长的参数，可以使用下面的方式： $ ls /etc/udev /etc/udev $ ls -al !$ ls -al /etc/udev -r–r–r– 1 root root 0 Jan 20 09:30 /etc/udev 这里的!$代表了上一条命令的最后一个参数。 使用上条命令第一个参数 而使用上条命令的第一个参数只需要使用!^，例如： $ ls -al !^ 去掉最后一个参数执行上一个命令 如果想执行上条命令，但不想带上最后一个参数： $ ls -al dir #假设dir是一个很长的字符串 $ !:- ls -al 什么场景下可能会用呢？比如你上一条命令最后一个参数是一个长长的字符串，而你恰好不想不用它，并且退格键删除又慢的时候，可以使用上面的方法。 使用上条命令的所有参数 前面说了使用上条命令的最后一个参数，那如果不是最后一个参数，该如何使用呢？很简单，使用!*即可。例如我们在输入find命令输错了，想要纠正的时候： $ finsd -name “foo.zip” # 这里特意输错了find命令 $ find !* find ./ -name “foo.zip” ./bar/foo.zip ./data/py/foo.zip 使用上条命令指定的参数 有的读者可能会问了，如果我只想用其中某个参数呢？按照![命令名]:[参数号]的规则即可。例如： $ cp -rf dira dirb/ #将dira拷贝到dirb $ ls -l !cp:2 #查看dira的内容 ls -l dira total 0 -rw-rw-r– 1 hyb hyb 0 Jan 20 16:18 barfile 当上条命令的参数很长，而你需要取用中间的某个参数时，效果就比较明显了。 执行上一条以关键字开头的命令 例如，执行上一条find命令： $ !find #执行上条以find开头的命令 逻辑非的作用 这个是它最为人所熟悉的作用，例如删除除了cfg结尾以外的所有文件： rm !(*.cfg) 小结 惊叹号的其他惊叹功能一览： !! 上一条命令 !$ 上一条命令中的最后一个参数 !:- 上一命令除了最后一个参数 !* 上一条命令中的所有参数 !str 最近一条以str开头的命令 !?str? 最近一条包含str的命令 !n 顺数第n条命令 !-n 倒数第n条命令 ^old^new 将上一命令中的old替换为new !!:gs/old/new 将上一命令中的old替换为new !scp:gs/old/new 将上一scp命令中的old替换为new 逻辑非的作用 这个是它最为人所熟悉的作用，例如删除除了cfg结尾以外的所有文件： rm !(*.cfg) #删除需谨慎</summary></entry><entry><title type="html">linux下编译报错ld</title><link href="http://0.0.0.0:4000/linux/2021/12/04/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99ld.html" rel="alternate" type="text/html" title="linux下编译报错ld" /><published>2021-12-04T00:00:00+08:00</published><updated>2021-12-04T00:00:00+08:00</updated><id>http://0.0.0.0:4000/linux/2021/12/04/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99ld</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2021/12/04/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99ld.html">&lt;p&gt;编译报错 canot find -lpng&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/bin/ld: cannot find &lt;span class=&quot;nt&quot;&gt;-lc&lt;/span&gt;
/usr/bin/ld: cannot find &lt;span class=&quot;nt&quot;&gt;-lltdl&lt;/span&gt;
/usr/bin/ld: cannot find &lt;span class=&quot;nt&quot;&gt;-lXtst&lt;/span&gt;
/usr/bin/ld: cannot find &lt;span class=&quot;nt&quot;&gt;-lpng&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个报错就是缺少库文件&lt;/p&gt;

&lt;p&gt;例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/usr/bin/ld: cannot find -lpng&lt;/code&gt;,则可以安装 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apt install libpng-dev&lt;/code&gt;试试&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">编译报错 canot find -lpng /usr/bin/ld: cannot find -lc /usr/bin/ld: cannot find -lltdl /usr/bin/ld: cannot find -lXtst /usr/bin/ld: cannot find -lpng 这个报错就是缺少库文件 例如/usr/bin/ld: cannot find -lpng,则可以安装 apt install libpng-dev试试</summary></entry><entry><title type="html">非LVM无损扩展硬盘分区(不推荐)</title><link href="http://0.0.0.0:4000/linux/2021/12/04/%E9%9D%9ELVM%E6%97%A0%E6%8D%9F%E6%89%A9%E5%B1%95%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA.html" rel="alternate" type="text/html" title="非LVM无损扩展硬盘分区(不推荐)" /><published>2021-12-04T00:00:00+08:00</published><updated>2021-12-04T00:00:00+08:00</updated><id>http://0.0.0.0:4000/linux/2021/12/04/%E9%9D%9ELVM%E6%97%A0%E6%8D%9F%E6%89%A9%E5%B1%95%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA</id><content type="html" xml:base="http://0.0.0.0:4000/linux/2021/12/04/%E9%9D%9ELVM%E6%97%A0%E6%8D%9F%E6%89%A9%E5%B1%95%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA.html">&lt;p&gt;安装公司samba服务器时对磁盘需求量估计不足，原本分的只有100GB，使用一段时间后磁盘就达到了 86%的使用量，&lt;img src=&quot;http://b.bst.126.net/common/portrait/face/preview/face15.gif&quot; alt=&quot;使用resize2fs调整ext4分区大小 - 明天的阳光 - 明天的阳光&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我的情况  将一块硬盘分成了两个区，一个100GB 一个60GB  ，只使用了前100GB空间的内容，后面的分区没有挂载，也没有使用。属于比较好处理的情况&lt;/p&gt;

&lt;p&gt;我的步骤：&lt;/p&gt;

&lt;p&gt;1、umount 掉sdb磁盘    若提示磁盘忙的话请使用fuser  命令将正在使用磁盘的程序kill掉。&lt;/p&gt;

&lt;p&gt;fuser -k -x -u -c /dev/hd1 或者fuser -kxuc /home&lt;/p&gt;

&lt;p&gt;2、使用 fdisk  /dev/sdb 命令调整分区大小   进去后先使用p命令查看磁柱号 ，切记用笔记下来 ~~~ 别说我没有提醒你哦。。&lt;/p&gt;

&lt;p&gt;3、删除掉这你需要变化的分区和需要借用的分区（意思就是准备变大的分区及准备变小的分区）然后再使用n命令建立分区，注意开始的磁柱号要和原来的一致，结束的磁柱号可以是你期望的磁柱号。。不知道的就输入你想要的磁盘大小即可 如+150GB&lt;/p&gt;

&lt;p&gt;4、建立需要调整的分区（借用的）。&lt;/p&gt;

&lt;p&gt;5、使用保存分区表。&lt;/p&gt;

&lt;p&gt;6、使用e2fsck  -f    /dev/sdb1     \ 需要调整的分区&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[root@localhost 桌面]# e2fsck -f /dev/sdb1 e2fsck 1.41.12 (17-May-2010) 第一步: 检查inode,块,和大小 第二步: 检查目录结构 第3步: 检查目录连接性 Pass 4: Checking reference counts 第5步: 检查簇概要信息 /dev/sdb1: 5496/6111232 files (1.8% non-contiguous), 18781569/24416784 blocks&lt;/p&gt;

&lt;p&gt;7、最后再使用 resize2fs /dev/sdb1 调整分区大小。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[root@BIGDATA 桌面]# resize2fs /dev/sdb1 resize2fs 1.41.12 (17-May-2010) Resizing the filesystem on /dev/sdb1 to 36622167 (4k) blocks. The filesystem on /dev/sdb1 is now 36622167 blocks long.&lt;/p&gt;

&lt;p&gt;8、再mount一个磁盘分区，看看是不是变大了呢 。&lt;/p&gt;

&lt;h2 id=&quot;用resize2fs-扩展linux分区大小&quot;&gt;用resize2fs 扩展linux分区大小&lt;/h2&gt;

&lt;p&gt;(2014-07-15 09:31:25)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;标签：&lt;/th&gt;
      &lt;th&gt;分类： &lt;a href=&quot;http://blog.sina.com.cn/s/articlelist_2099389457_6_1.html&quot;&gt;linux&lt;/a&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最近发现备份服务器的分区空间开始告警，需要扩充磁盘空间， 在存储中把卷扩大后， linux 系统中还不能马上识别， 因为没有用linux 的LVM 来管理磁盘， 所以只好用 fdisk 来扩充分区了。&lt;/p&gt;

&lt;p&gt;用fdisk 先删除原有分区， 再重建分区， 起始cylinder 绝对不可以改，这样会破坏原分区的数据。&lt;/p&gt;

&lt;p&gt;分区建好后， 就可以用e2fsck 先检查一下分区， 再用resize2fs 扩大就可以了。&lt;/p&gt;

&lt;p&gt;root@SHZ-VM-001:/# fdisk /dev/sdb&lt;/p&gt;

&lt;p&gt;WARNING: DOS-compatible mode is deprecated. It’s strongly recommended to&lt;/p&gt;

&lt;p&gt;​        switch off the mode (command ‘c’) and change display units to&lt;/p&gt;

&lt;p&gt;​        sectors (command ‘u’).&lt;/p&gt;

&lt;p&gt;Command (m for help): p&lt;/p&gt;

&lt;p&gt;Disk /dev/sdb: 322.1 GB, 322122547200 bytes&lt;/p&gt;

&lt;p&gt;255 heads, 63 sectors/track, 39162 cylinders&lt;/p&gt;

&lt;p&gt;Units = cylinders of 16065 * 512 = 8225280 bytes&lt;/p&gt;

&lt;p&gt;Sector size (logical/physical): 512 bytes / 512 bytes&lt;/p&gt;

&lt;p&gt;I/O size (minimum/optimal): 512 bytes / 512 bytes&lt;/p&gt;

&lt;p&gt;Disk identifier: 0x76148198&lt;/p&gt;

&lt;p&gt;Device Boot      Start        End     Blocks   Id  System&lt;/p&gt;

&lt;p&gt;/dev/sdb1             1      26108  209712478+  83  Linux&lt;/p&gt;

&lt;p&gt;Command (m for help): m&lt;/p&gt;

&lt;p&gt;Command action&lt;/p&gt;

&lt;p&gt;a  toggle a bootable flag&lt;/p&gt;

&lt;p&gt;b   edit bsd disklabel&lt;/p&gt;

&lt;p&gt;c  toggle the dos compatibility flag&lt;/p&gt;

&lt;p&gt;d  delete a partition&lt;/p&gt;

&lt;p&gt;l   list known partition types&lt;/p&gt;

&lt;p&gt;m  print this menu&lt;/p&gt;

&lt;p&gt;n   add a new partition&lt;/p&gt;

&lt;p&gt;o  create a new empty DOS partition table&lt;/p&gt;

&lt;p&gt;p  print the partition table&lt;/p&gt;

&lt;p&gt;q   quit without saving changes&lt;/p&gt;

&lt;p&gt;s  create a new empty Sun disklabel&lt;/p&gt;

&lt;p&gt;t  change a partition’s system id&lt;/p&gt;

&lt;p&gt;u  change display/entry units&lt;/p&gt;

&lt;p&gt;v  verify the partition table&lt;/p&gt;

&lt;p&gt;w  write table to disk and exit&lt;/p&gt;

&lt;p&gt;x  extra functionality (experts only)&lt;/p&gt;

&lt;p&gt;Command (m for help): d&lt;/p&gt;

&lt;p&gt;Selected partition 1&lt;/p&gt;

&lt;p&gt;Command (m for help): p&lt;/p&gt;

&lt;p&gt;Disk /dev/sdb: 322.1 GB, 322122547200 bytes&lt;/p&gt;

&lt;p&gt;255 heads, 63 sectors/track, 39162 cylinders&lt;/p&gt;

&lt;p&gt;Units = cylinders of 16065 * 512 = 8225280 bytes&lt;/p&gt;

&lt;p&gt;Sector size (logical/physical): 512 bytes / 512 bytes&lt;/p&gt;

&lt;p&gt;I/O size (minimum/optimal): 512 bytes / 512 bytes&lt;/p&gt;

&lt;p&gt;Disk identifier: 0x76148198&lt;/p&gt;

&lt;p&gt;Device Boot      Start        End     Blocks   Id  System&lt;/p&gt;

&lt;p&gt;Command (m for help): m&lt;/p&gt;

&lt;p&gt;Command action&lt;/p&gt;

&lt;p&gt;a  toggle a bootable flag&lt;/p&gt;

&lt;p&gt;b   edit bsd disklabel&lt;/p&gt;

&lt;p&gt;c  toggle the dos compatibility flag&lt;/p&gt;

&lt;p&gt;d  delete a partition&lt;/p&gt;

&lt;p&gt;l   list known partition types&lt;/p&gt;

&lt;p&gt;m  print this menu&lt;/p&gt;

&lt;p&gt;n   add a new partition&lt;/p&gt;

&lt;p&gt;o  create a new empty DOS partition table&lt;/p&gt;

&lt;p&gt;p  print the partition table&lt;/p&gt;

&lt;p&gt;q   quit without saving changes&lt;/p&gt;

&lt;p&gt;s  create a new empty Sun disklabel&lt;/p&gt;

&lt;p&gt;t  change a partition’s system id&lt;/p&gt;

&lt;p&gt;u  change display/entry units&lt;/p&gt;

&lt;p&gt;v  verify the partition table&lt;/p&gt;

&lt;p&gt;w  write table to disk and exit&lt;/p&gt;

&lt;p&gt;x  extra functionality (experts only)&lt;/p&gt;

&lt;p&gt;Command (m for help): n&lt;/p&gt;

&lt;p&gt;Command action&lt;/p&gt;

&lt;p&gt;e  extended&lt;/p&gt;

&lt;p&gt;p  primary partition (1-4)&lt;/p&gt;

&lt;p&gt;p&lt;/p&gt;

&lt;p&gt;Partition number (1-4):&lt;/p&gt;

&lt;p&gt;Value out of range.&lt;/p&gt;

&lt;p&gt;Partition number (1-4): 1&lt;/p&gt;

&lt;p&gt;First cylinder (1-39162, default 1):&lt;/p&gt;

&lt;p&gt;Using default value 1&lt;/p&gt;

&lt;p&gt;Last cylinder, +cylinders or +size{K,M,G} (1-39162, default 39162):&lt;/p&gt;

&lt;p&gt;Using default value 39162&lt;/p&gt;

&lt;p&gt;Command (m for help): p&lt;/p&gt;

&lt;p&gt;Disk /dev/sdb: 322.1 GB, 322122547200 bytes&lt;/p&gt;

&lt;p&gt;255 heads, 63 sectors/track, 39162 cylinders&lt;/p&gt;

&lt;p&gt;Units = cylinders of 16065 * 512 = 8225280 bytes&lt;/p&gt;

&lt;p&gt;Sector size (logical/physical): 512 bytes / 512 bytes&lt;/p&gt;

&lt;p&gt;I/O size (minimum/optimal): 512 bytes / 512 bytes&lt;/p&gt;

&lt;p&gt;Disk identifier: 0x76148198&lt;/p&gt;

&lt;p&gt;Device Boot      Start        End     Blocks   Id  System&lt;/p&gt;

&lt;p&gt;/dev/sdb1             1      39162  314568733+  83  Linux&lt;/p&gt;

&lt;p&gt;Command (m for help): w&lt;/p&gt;

&lt;p&gt;The partition table has been altered!&lt;/p&gt;

&lt;p&gt;Calling ioctl() to re-read partition table.&lt;/p&gt;

&lt;p&gt;Syncing disks.&lt;/p&gt;

&lt;p&gt;root@SHZ-VM-001:/#&lt;/p&gt;

&lt;p&gt;root@SHZ-VM-001:/#&lt;/p&gt;

&lt;p&gt;root@SHZ-VM-001:/#&lt;/p&gt;

&lt;p&gt;root@SHZ-VM-001:/# resize2fs /dev/sdb1&lt;/p&gt;

&lt;p&gt;resize2fs 1.41.11 (14-Mar-2010)&lt;/p&gt;

&lt;p&gt;Please run ‘e2fsck -f /dev/sdb1’ first.&lt;/p&gt;

&lt;p&gt;root@SHZ-VM-001:/# e2fsck -f /dev/sdb1&lt;/p&gt;

&lt;p&gt;e2fsck 1.41.11 (14-Mar-2010)&lt;/p&gt;

&lt;p&gt;Pass 1: Checking inodes, blocks, and sizes&lt;/p&gt;

&lt;p&gt;Pass 2: Checking directory structure&lt;/p&gt;

&lt;p&gt;Pass 3: Checking directory connectivity&lt;/p&gt;

&lt;p&gt;Pass 4: Checking reference counts&lt;/p&gt;

&lt;p&gt;Pass 5: Checking group summary information&lt;/p&gt;

&lt;p&gt;/dev/sdb1: 474754/13107200 files (0.4% non-contiguous), 45135492/52428119 blocks&lt;/p&gt;

&lt;p&gt;root@SHZ-VM-001:/# resize2fs /dev/sdb1&lt;/p&gt;

&lt;p&gt;resize2fs 1.41.11 (14-Mar-2010)&lt;/p&gt;

&lt;p&gt;Resizing the filesystem on /dev/sdb1 to 78642183 (4k) blocks.&lt;/p&gt;

&lt;p&gt;The filesystem on /dev/sdb1 is now 78642183 blocks long.&lt;/p&gt;

&lt;p&gt;root@SHZ-VM-001:/# mount /dev/sdb1 /lv_backup/&lt;/p&gt;

&lt;p&gt;root@SHZ-VM-001:/# ls -l /lv_backup/&lt;/p&gt;

&lt;p&gt;lost+found/   rsync_backup/&lt;/p&gt;

&lt;p&gt;root@SHZ-VM-001:/# ls -l /lv_backup/rsync_backup/&lt;/p&gt;

&lt;p&gt;total 24&lt;/p&gt;

&lt;p&gt;drwxr-xr-x  6 root   root 4096 2014-07-14 15:26 dmz&lt;/p&gt;

&lt;p&gt;drwxr-xr-x 60 nobody root 4096 2014-07-15 04:00 forge-router&lt;/p&gt;

&lt;p&gt;drwxr-xr-x  4 nobody root 4096 2014-06-17 11:21 sz01003&lt;/p&gt;

&lt;p&gt;drwxr-xr-x  2 nobody root 4096 2014-07-14 15:17 sz01006&lt;/p&gt;

&lt;p&gt;drwxr-xr-x  4 nobody root 4096 2014-06-17 22:00 sz01007&lt;/p&gt;

&lt;p&gt;drwxr-xr-x  5 nobody root 4096 2014-06-17 12:54 sz01009&lt;/p&gt;

&lt;p&gt;root@SHZ-VM-001:/# df -h&lt;/p&gt;

&lt;p&gt;Filesystem          Size  Used Avail Use% Mounted on&lt;/p&gt;

&lt;p&gt;/dev/sda1            76G   15G   58G  21% /&lt;/p&gt;

&lt;p&gt;none               1001M  172K 1001M   1% /dev&lt;/p&gt;

&lt;p&gt;none               1005M    0 1005M   0% /dev/shm&lt;/p&gt;

&lt;p&gt;none               1005M   60K 1005M   1% /var/run&lt;/p&gt;

&lt;p&gt;none               1005M    0 1005M   0% /var/lock&lt;/p&gt;

&lt;p&gt;none               1005M    0 1005M   0% /lib/init/rw&lt;/p&gt;

&lt;p&gt;/dev/sdb1           296G  170G  112G  61% /lv_backup&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">安装公司samba服务器时对磁盘需求量估计不足，原本分的只有100GB，使用一段时间后磁盘就达到了 86%的使用量， 我的情况 将一块硬盘分成了两个区，一个100GB 一个60GB ，只使用了前100GB空间的内容，后面的分区没有挂载，也没有使用。属于比较好处理的情况 我的步骤： 1、umount 掉sdb磁盘 若提示磁盘忙的话请使用fuser 命令将正在使用磁盘的程序kill掉。 fuser -k -x -u -c /dev/hd1 或者fuser -kxuc /home 2、使用 fdisk /dev/sdb 命令调整分区大小 进去后先使用p命令查看磁柱号 ，切记用笔记下来 ~~~ 别说我没有提醒你哦。。 3、删除掉这你需要变化的分区和需要借用的分区（意思就是准备变大的分区及准备变小的分区）然后再使用n命令建立分区，注意开始的磁柱号要和原来的一致，结束的磁柱号可以是你期望的磁柱号。。不知道的就输入你想要的磁盘大小即可 如+150GB 4、建立需要调整的分区（借用的）。 5、使用保存分区表。 6、使用e2fsck -f /dev/sdb1 \ 需要调整的分区 [root@localhost 桌面]# e2fsck -f /dev/sdb1 e2fsck 1.41.12 (17-May-2010) 第一步: 检查inode,块,和大小 第二步: 检查目录结构 第3步: 检查目录连接性 Pass 4: Checking reference counts 第5步: 检查簇概要信息 /dev/sdb1: 5496/6111232 files (1.8% non-contiguous), 18781569/24416784 blocks 7、最后再使用 resize2fs /dev/sdb1 调整分区大小。 [root@BIGDATA 桌面]# resize2fs /dev/sdb1 resize2fs 1.41.12 (17-May-2010) Resizing the filesystem on /dev/sdb1 to 36622167 (4k) blocks. The filesystem on /dev/sdb1 is now 36622167 blocks long. 8、再mount一个磁盘分区，看看是不是变大了呢 。 用resize2fs 扩展linux分区大小 (2014-07-15 09:31:25) 标签： 分类： linux     最近发现备份服务器的分区空间开始告警，需要扩充磁盘空间， 在存储中把卷扩大后， linux 系统中还不能马上识别， 因为没有用linux 的LVM 来管理磁盘， 所以只好用 fdisk 来扩充分区了。 用fdisk 先删除原有分区， 再重建分区， 起始cylinder 绝对不可以改，这样会破坏原分区的数据。 分区建好后， 就可以用e2fsck 先检查一下分区， 再用resize2fs 扩大就可以了。 root@SHZ-VM-001:/# fdisk /dev/sdb WARNING: DOS-compatible mode is deprecated. It’s strongly recommended to ​ switch off the mode (command ‘c’) and change display units to ​ sectors (command ‘u’). Command (m for help): p Disk /dev/sdb: 322.1 GB, 322122547200 bytes 255 heads, 63 sectors/track, 39162 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x76148198 Device Boot Start End Blocks Id System /dev/sdb1 1 26108 209712478+ 83 Linux Command (m for help): m Command action a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition l list known partition types m print this menu n add a new partition o create a new empty DOS partition table p print the partition table q quit without saving changes s create a new empty Sun disklabel t change a partition’s system id u change display/entry units v verify the partition table w write table to disk and exit x extra functionality (experts only) Command (m for help): d Selected partition 1 Command (m for help): p Disk /dev/sdb: 322.1 GB, 322122547200 bytes 255 heads, 63 sectors/track, 39162 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x76148198 Device Boot Start End Blocks Id System Command (m for help): m Command action a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition l list known partition types m print this menu n add a new partition o create a new empty DOS partition table p print the partition table q quit without saving changes s create a new empty Sun disklabel t change a partition’s system id u change display/entry units v verify the partition table w write table to disk and exit x extra functionality (experts only) Command (m for help): n Command action e extended p primary partition (1-4) p Partition number (1-4): Value out of range. Partition number (1-4): 1 First cylinder (1-39162, default 1): Using default value 1 Last cylinder, +cylinders or +size{K,M,G} (1-39162, default 39162): Using default value 39162 Command (m for help): p Disk /dev/sdb: 322.1 GB, 322122547200 bytes 255 heads, 63 sectors/track, 39162 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x76148198 Device Boot Start End Blocks Id System /dev/sdb1 1 39162 314568733+ 83 Linux Command (m for help): w The partition table has been altered! Calling ioctl() to re-read partition table. Syncing disks. root@SHZ-VM-001:/# root@SHZ-VM-001:/# root@SHZ-VM-001:/# root@SHZ-VM-001:/# resize2fs /dev/sdb1 resize2fs 1.41.11 (14-Mar-2010) Please run ‘e2fsck -f /dev/sdb1’ first. root@SHZ-VM-001:/# e2fsck -f /dev/sdb1 e2fsck 1.41.11 (14-Mar-2010) Pass 1: Checking inodes, blocks, and sizes Pass 2: Checking directory structure Pass 3: Checking directory connectivity Pass 4: Checking reference counts Pass 5: Checking group summary information /dev/sdb1: 474754/13107200 files (0.4% non-contiguous), 45135492/52428119 blocks root@SHZ-VM-001:/# resize2fs /dev/sdb1 resize2fs 1.41.11 (14-Mar-2010) Resizing the filesystem on /dev/sdb1 to 78642183 (4k) blocks. The filesystem on /dev/sdb1 is now 78642183 blocks long. root@SHZ-VM-001:/# mount /dev/sdb1 /lv_backup/ root@SHZ-VM-001:/# ls -l /lv_backup/ lost+found/ rsync_backup/ root@SHZ-VM-001:/# ls -l /lv_backup/rsync_backup/ total 24 drwxr-xr-x 6 root root 4096 2014-07-14 15:26 dmz drwxr-xr-x 60 nobody root 4096 2014-07-15 04:00 forge-router drwxr-xr-x 4 nobody root 4096 2014-06-17 11:21 sz01003 drwxr-xr-x 2 nobody root 4096 2014-07-14 15:17 sz01006 drwxr-xr-x 4 nobody root 4096 2014-06-17 22:00 sz01007 drwxr-xr-x 5 nobody root 4096 2014-06-17 12:54 sz01009 root@SHZ-VM-001:/# df -h Filesystem Size Used Avail Use% Mounted on /dev/sda1 76G 15G 58G 21% / none 1001M 172K 1001M 1% /dev none 1005M 0 1005M 0% /dev/shm none 1005M 60K 1005M 1% /var/run none 1005M 0 1005M 0% /var/lock none 1005M 0 1005M 0% /lib/init/rw /dev/sdb1 296G 170G 112G 61% /lv_backup</summary></entry></feed>